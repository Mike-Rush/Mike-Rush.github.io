<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>数字IC设计基础知识100题（Part II） | Mike Rush&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="转载不必注明出处，就说是你自己写的">
<meta property="og:type" content="article">
<meta property="og:title" content="数字IC设计基础知识100题（Part II）">
<meta property="og:url" content="https://mike-rush.github.io/2020/05/13/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80100%E9%A2%98P2/index.html">
<meta property="og:site_name" content="Mike Rush&#39;s Blog">
<meta property="og:description" content="转载不必注明出处，就说是你自己写的">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-05-13T03:46:14.000Z">
<meta property="article:modified_time" content="2020-05-13T03:54:01.033Z">
<meta property="article:author" content="Mike Rush">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Mike Rush&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Mike Rush&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://Mike-Rush.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-数字IC设计基础100题P2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/13/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80100%E9%A2%98P2/" class="article-date">
  <time datetime="2020-05-13T03:46:14.000Z" itemprop="datePublished">2020-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      数字IC设计基础知识100题（Part II）
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>转载不必注明出处，就说是你自己写的</p>
<a id="more"></a>

<h3 id="51：SRAM，FLASH-MEMORY，DRAM，SSRAM及SDRAM的区别"><a href="#51：SRAM，FLASH-MEMORY，DRAM，SSRAM及SDRAM的区别" class="headerlink" title="51：SRAM，FLASH MEMORY，DRAM，SSRAM及SDRAM的区别?"></a>51：SRAM，FLASH MEMORY，DRAM，SSRAM及SDRAM的区别?</h3><p>SRAM：静态随机存储器，存取速度快，但容量小，掉电后数据会丢失，不像DRAM 需要不停的REFRESH，制造成本较高，通常用来作为快取(CACHE) 记忆体使用。</p>
<p>FLASH：闪存，存取速度慢，容量大，掉电后数据不会丢失</p>
<p>DRAM：动态随机存储器，必须不断的重新的加强(REFRESHED) 电位差量，否则电位差将降低至无法有足够的能量表现每一个记忆单位处于何种状态。价格比SRAM便宜，但访问速度较慢，耗电量较大，常用作计算机的内存使用。</p>
<p>SSRAM：即同步静态随机存取存储器。对于SSRAM的所有访问都在时钟的上升/下降沿启动。地址、数据输入和其它控制信号均于时钟信号相关。</p>
<p>SDRAM：即同步动态随机存取存储器。</p>
<h3 id="52：写出四种复用方式？"><a href="#52：写出四种复用方式？" class="headerlink" title="52：写出四种复用方式？"></a>52：写出四种复用方式？</h3><p>四种复用方式：频分多路复用（FDMA），时分多路复用（TDMA），码分多路复用（CDMA），波分多路复用（WDMA）。</p>
<h3 id="53：ASIC设计流程中什么时候修正Setup-time-violation-和Hold-time-violation-如何修正？解释setup和hold-time-violation，画图说明，并说明解决办法。"><a href="#53：ASIC设计流程中什么时候修正Setup-time-violation-和Hold-time-violation-如何修正？解释setup和hold-time-violation，画图说明，并说明解决办法。" class="headerlink" title="53：ASIC设计流程中什么时候修正Setup time violation 和Hold time violation?如何修正？解释setup和hold time violation，画图说明，并说明解决办法。"></a>53：ASIC设计流程中什么时候修正Setup time violation 和Hold time violation?如何修正？解释setup和hold time violation，画图说明，并说明解决办法。</h3><p>见前面的建立时间和保持时间</p>
<h3 id="54：给出一个组合逻辑电路，要求分析逻辑功能。"><a href="#54：给出一个组合逻辑电路，要求分析逻辑功能。" class="headerlink" title="54：给出一个组合逻辑电路，要求分析逻辑功能。"></a>54：给出一个组合逻辑电路，要求分析逻辑功能。</h3><p>所谓组合逻辑电路的分析，就是找出给定逻辑电路输出和输入之间的关系，并指出电路的逻辑功能。</p>
<p>分析过程一般按下列步骤进行：</p>
<p>1：根据给定的逻辑电路，从输入端开始，逐级推导出输出端的逻辑函数表达式。</p>
<p>2：根据输出函数表达式列出真值表；</p>
<p>3：用文字概括处电路的逻辑功能；</p>
<h3 id="55：如何防止亚稳态？"><a href="#55：如何防止亚稳态？" class="headerlink" title="55：如何防止亚稳态？"></a>55：如何防止亚稳态？</h3><p>亚稳态是指触发器无法在某个规定时间段内达到一个可确认的状态。当一个触发器进入亚稳态时，既无法预测该单元的输出电平，也无法预测何时输出才能稳定在某个 正确的电平上。在这个稳定期间，触发器输出一些中间级电平，或者可能处于振荡状态，并且这种无用的输出电平可以沿信号通道上的各个触发器级联式传播下去。</p>
<p>解决方法：</p>
<p>1 降低系统时钟频率</p>
<p>2 用反应更快的FF</p>
<p>3 引入同步机制，防止亚稳态传播（可以采用前面说的加两级触发器）。</p>
<p>4 改善时钟质量，用边沿变化快速的时钟信号</p>
<h3 id="56：基尔霍夫定理的内容"><a href="#56：基尔霍夫定理的内容" class="headerlink" title="56：基尔霍夫定理的内容"></a>56：基尔霍夫定理的内容</h3><p>基尔霍夫定律包括电流定律和电压定律：</p>
<p>电流定律：在集总电路中，在任一瞬时，流向某一结点的电流之和恒等于由该结点流出的电流之和。</p>
<p>电压定律：在集总电路中，在任一瞬间，沿电路中的任一回路绕行一周，在该回路上电动势之和恒等于各电阻上的电压降之和。</p>
<h3 id="57：描述反馈电路的概念，列举他们的应用。"><a href="#57：描述反馈电路的概念，列举他们的应用。" class="headerlink" title="57：描述反馈电路的概念，列举他们的应用。"></a>57：描述反馈电路的概念，列举他们的应用。</h3><p>反馈，就是在电路系统中，把输出回路中的电量（电压或电流）输入到输入回路中去。</p>
<p>反馈的类型有：电压串联负反馈、电流串联负反馈、电压并联负反馈、电流并联负反馈。</p>
<p>负反馈的优点：降低放大器的增益灵敏度，改变输入电阻和输出电阻，改善放大器的线性和非线性失真，有效地扩展放大器的通频带，自动调节作用。</p>
<p>电压负反馈的特点：电路的输出电压趋向于维持恒定。</p>
<p>电流负反馈的特点：电路的输出电流趋向于维持恒定。</p>
<h3 id="58：有源滤波器和无源滤波器的区别"><a href="#58：有源滤波器和无源滤波器的区别" class="headerlink" title="58：有源滤波器和无源滤波器的区别"></a>58：有源滤波器和无源滤波器的区别</h3><p>无源滤波器：这种电路主要有无源元件R、L和C组成</p>
<p>有源滤波器：集成运放和R、C组成，具有不用电感、体积小、重量轻等优点。</p>
<p>集成运放的开环电压增益和输入阻抗均很高，输出电阻小，构成有源滤波电路后还具有一定的电压放大和缓冲作用。但集成运放带宽有限，所以目前的有源滤波电路的工作频率难以做得很高。</p>
<h3 id="59：给了reg的setup，hold时间，求中间组合逻辑的delay范围。"><a href="#59：给了reg的setup，hold时间，求中间组合逻辑的delay范围。" class="headerlink" title="59：给了reg的setup，hold时间，求中间组合逻辑的delay范围。"></a>59：给了reg的setup，hold时间，求中间组合逻辑的delay范围。</h3><p>Tdelay &lt; Tperiod - Tsetup – Thold<br>Tperiod &gt; Tsetup + Thold +Tdelay （用来计算最高时钟频率）<br>Tco= Tsetup + Thold 即触发器的传输延时</p>
<h3 id="60：时钟周期为T-触发器D1的寄存器到输出时间（触发器延时Tco）最大为T1max，最小为T1min。组合逻辑电路最大延迟为T2max-最小为T2min。问，触发器D2的建立时间T3和保持时间应满足什么条件。"><a href="#60：时钟周期为T-触发器D1的寄存器到输出时间（触发器延时Tco）最大为T1max，最小为T1min。组合逻辑电路最大延迟为T2max-最小为T2min。问，触发器D2的建立时间T3和保持时间应满足什么条件。" class="headerlink" title="60：时钟周期为T,触发器D1的寄存器到输出时间（触发器延时Tco）最大为T1max，最小为T1min。组合逻辑电路最大延迟为T2max,最小为T2min。问，触发器D2的建立时间T3和保持时间应满足什么条件。"></a>60：时钟周期为T,触发器D1的寄存器到输出时间（触发器延时Tco）最大为T1max，最小为T1min。组合逻辑电路最大延迟为T2max,最小为T2min。问，触发器D2的建立时间T3和保持时间应满足什么条件。</h3><p>T3setup&gt;T+T2max 时钟沿到来之前数据稳定的时间（越大越好），一个时钟周期T加上最大的逻辑延时。</p>
<p>T3hold&gt;T1min+T2min 时钟沿到来之后数据保持的最短时间，一定要大于最小的延时也就是T1min+T2min</p>
<h3 id="61：给出某个一般时序电路的图，有Tsetup，Tdelay，Tck-gt-q（Tco），还有-clock的delay-写出决定最大时钟的因素，同时给出表达式。"><a href="#61：给出某个一般时序电路的图，有Tsetup，Tdelay，Tck-gt-q（Tco），还有-clock的delay-写出决定最大时钟的因素，同时给出表达式。" class="headerlink" title="61：给出某个一般时序电路的图，有Tsetup，Tdelay，Tck-&gt;q（Tco），还有 clock的delay,写出决定最大时钟的因素，同时给出表达式。"></a>61：给出某个一般时序电路的图，有Tsetup，Tdelay，Tck-&gt;q（Tco），还有 clock的delay,写出决定最大时钟的因素，同时给出表达式。</h3><p>T+Tclkdealy&gt;Tsetup+Tco+Tdelay;<br>Thold&gt;Tclkdelay+Tco+Tdelay; 保持时间与时钟周期无关</p>
<h3 id="62：实现三分频电路，3-2分频电路等（偶数倍分频奇数倍分频）"><a href="#62：实现三分频电路，3-2分频电路等（偶数倍分频奇数倍分频）" class="headerlink" title="62：实现三分频电路，3/2分频电路等（偶数倍分频奇数倍分频）"></a>62：实现三分频电路，3/2分频电路等（偶数倍分频奇数倍分频）</h3><p>不解释</p>
<h3 id="63：名词解释"><a href="#63：名词解释" class="headerlink" title="63：名词解释"></a>63：名词解释</h3><p>CMOS（Complementary Metal Oxide Semiconductor），互补金属氧化物半导体，电压控制的一种放大器件。是组成CMOS数字集成电路的基本单元。 </p>
<p>MCU(Micro Controller Unit)中文名称为微控制单元，又称单片微型计算机(Single Chip Microcomputer)或者单片机，是指随着大规模集成电路的出现及其发展，将计算机的CPU、RAM、ROM、定时数计器和多种I/O接口集成在一片芯片上，形成芯片级的计算机，为不同的应用场合做不同组合控制。</p>
<p>RISC（reduced instruction set computer，精简指令集计算机）是一种执行较少类型计算机指令的微处理器，起源于80年代的MIPS主机（即RISC机），RISC机中采用的微处理器统称RISC处理器。这样一来，它能够以更快的速度执行操作（每秒执行更多百万条指令，即MIPS）。因为计算机执行每个指令类型都需要额外的晶体管和电路元件，计算机指令集越大就会使微处理器更复杂，执行操作也会更慢。</p>
<p>CISC是复杂指令系统计算机（Complex Instruction Set Computer）的简称，微处理器是台式计算机系统的基本处理部件，每个微处理器的核心是运行指令的电路。指令由完成任务的多个步骤所组成，把数值传送进寄存器或进行相加运算。</p>
<p>DSP（digital signal processor）是一种独特的微处理器，是以数字信号来处理大量信息的器件。其工作原理是接收模拟信号，转换为0或1的数字信号。 再对数字信号进行修改、删除、强化，并在其他系统芯片中把数字数据解译回模拟数据或实际环境格式。它不仅具有可编程性，而且其实时运行速度可达每秒数以千 万条复杂指令程序，远远超过通用微处理器，是数字化电子世界中日益重要的电脑芯片。它的强大数据处理能力和高运行速度，是最值得称道的两大特色。</p>
<p>FPGA（Field－Programmable GateArray），即现场可编程门阵列，它是在PAL、GAL、CPLD等可编程器件的基础上进一步发展的产物。它是作为专用集成电路（ASIC）领域中的一种半定制电路而出现的，既解决了定制电路的不足，又克服了原有可编程器件门电路数有限的缺点。 </p>
<p>ASIC:专用集成电路，它是面向专门用途的电路，专门为一个用户设计和制造的。根据一个用户的特定要求，能以低研制成本，短、交货周期供货的全定制，半定制集成电路。与门阵列等其它ASIC(ApplicationSpecific IC)相比，它们又具有设计开发周期短、设计制造成本低、开发工具先进、标准产品无需测试、质量稳定以及可实时在线检验等优点 </p>
<p>PCI(Peripheral Component Interconnect) 外围组件互连，一种由英特尔（Intel）公司1991年推出的用于定义局部总线的标准。 </p>
<p>ECC是“Error Correcting Code”的简写，中文名称是“错误检查和纠正”。ECC是一种能够实现“错误检查和纠正”的技术，ECC内存就是应用了这种技术的内存，一般多应用在服务器及图形工作站上，这将使整个电脑系统在工作时更趋于安全稳定。</p>
<p>DDR=Double Data Rate双倍速率同步动态随机存储器。严格的说DDR应该叫DDR SDRAM，人们习惯称为DDR，其中，SDRAM 是Synchronous Dynamic Random Access Memory的缩写，即同步动态随机存取存储器。 </p>
<p>IRQ全称为Interrupt Request，即是“中断请求”的意思（以下使用IRQ称呼）。IRQ的作用就是在我们所用的电脑中，执行硬件中断请求的动作，用来停止其相关硬件的工作状态 </p>
<p>USB ,是英文Universal Serial BUS（通用串行总线）的缩写，而其中文简称为“通串线，是一个外部总线标准，用于规范电脑与外部设备的连接和通讯。 </p>
<p>BIOS是英文”Basic Input Output System”的缩略语，直译过来后中文名称就是”基本输入输出系统”。其实，它是一组固化到计算机内主板上一个ROM芯片上的程序，它保存着计算机最重要的基本输入输出的程序、系统设置信息、开机后自检程序和系统自启动程序。其主要功能是为计算机提供最底层的、最直接的硬件设置和控制。</p>
<h3 id="64：BJT，MOS特性曲线"><a href="#64：BJT，MOS特性曲线" class="headerlink" title="64：BJT，MOS特性曲线"></a>64：BJT，MOS特性曲线</h3><p>不解释</p>
<h3 id="65：Please-show-the-CMOS-inverter-schematic-layout-and-its-cross-section-with-P-well-process-Plot-itstransfer-curve-Vout-Vin-and-also-explain-the-operation-region-of-PMOS-and-NMOS-for-each-segment-of-the-transfer-curve"><a href="#65：Please-show-the-CMOS-inverter-schematic-layout-and-its-cross-section-with-P-well-process-Plot-itstransfer-curve-Vout-Vin-and-also-explain-the-operation-region-of-PMOS-and-NMOS-for-each-segment-of-the-transfer-curve" class="headerlink" title="65：Please show the CMOS inverter schematic, layout and its cross section with P-well process. Plot itstransfer curve (Vout-Vin) and also explain the operation region of PMOS and NMOS for each segment of the transfer curve?"></a>65：Please show the CMOS inverter schematic, layout and its cross section with P-well process. Plot itstransfer curve (Vout-Vin) and also explain the operation region of PMOS and NMOS for each segment of the transfer curve?</h3><h3 id="66：To-design-a-CMOS-inverter-with-balance-rise-and-fall-time-please-define-the-ration-of-channel-width-of-PMOS-and-NMOS-and-explain"><a href="#66：To-design-a-CMOS-inverter-with-balance-rise-and-fall-time-please-define-the-ration-of-channel-width-of-PMOS-and-NMOS-and-explain" class="headerlink" title="66：To design a CMOS inverter with balance rise and fall time, please define the ration of channel width of PMOS and NMOS and explain?"></a>66：To design a CMOS inverter with balance rise and fall time, please define the ration of channel width of PMOS and NMOS and explain?</h3><h3 id="67：Please-draw-thetransistor-level-schematic-of-a-CMOS-2-input-AND-gate-and-explain-which-input-has-faster-response-for-output-rising-edge-less-delay-time-。"><a href="#67：Please-draw-thetransistor-level-schematic-of-a-CMOS-2-input-AND-gate-and-explain-which-input-has-faster-response-for-output-rising-edge-less-delay-time-。" class="headerlink" title="67：Please draw thetransistor level schematic of a CMOS 2 input AND gate and explain which input has faster response for output rising edge.(less delay time)。"></a>67：Please draw thetransistor level schematic of a CMOS 2 input AND gate and explain which input has faster response for output rising edge.(less delay time)。</h3><h3 id="68：为了实现逻辑Y-A’B-AB’-CD，请选用以下逻辑中的一种，并说明为什么？1）INV-2）AND-3）OR-4）NAND-5）NOR-6）XOR"><a href="#68：为了实现逻辑Y-A’B-AB’-CD，请选用以下逻辑中的一种，并说明为什么？1）INV-2）AND-3）OR-4）NAND-5）NOR-6）XOR" class="headerlink" title="68：为了实现逻辑Y=A’B+AB’+CD，请选用以下逻辑中的一种，并说明为什么？1）INV 2）AND 3）OR 4）NAND 5）NOR 6）XOR"></a>68：为了实现逻辑Y=A’B+AB’+CD，请选用以下逻辑中的一种，并说明为什么？1）INV 2）AND 3）OR 4）NAND 5）NOR 6）XOR</h3><h3 id="69：用波形表示D触发器的功能。"><a href="#69：用波形表示D触发器的功能。" class="headerlink" title="69：用波形表示D触发器的功能。"></a>69：用波形表示D触发器的功能。</h3><h3 id="70：用传输门和倒向器搭一个边沿触发器（DFF）"><a href="#70：用传输门和倒向器搭一个边沿触发器（DFF）" class="headerlink" title="70：用传输门和倒向器搭一个边沿触发器（DFF）"></a>70：用传输门和倒向器搭一个边沿触发器（DFF）</h3><h3 id="71：用逻辑门画出D触发器。"><a href="#71：用逻辑门画出D触发器。" class="headerlink" title="71：用逻辑门画出D触发器。"></a>71：用逻辑门画出D触发器。</h3><h3 id="72：画出DFF的结构图-用verilog实现之。"><a href="#72：画出DFF的结构图-用verilog实现之。" class="headerlink" title="72：画出DFF的结构图,用verilog实现之。"></a>72：画出DFF的结构图,用verilog实现之。</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 	</span><br><span class="line"><span class="keyword">module</span> dff(clk,d,qout);</span><br><span class="line">    <span class="keyword">input</span> clk,d;</span><br><span class="line">    <span class="keyword">output</span> qout;</span><br><span class="line">    <span class="keyword">reg</span> qout;</span><br><span class="line">    <span class="keyword">always</span>@(posedgeclk)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!reset)</span><br><span class="line">        qout&lt;=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        qout&lt;=d;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>         
<h3 id="73：画出一种CMOS的D锁存器的电路图和版图。"><a href="#73：画出一种CMOS的D锁存器的电路图和版图。" class="headerlink" title="73：画出一种CMOS的D锁存器的电路图和版图。"></a>73：画出一种CMOS的D锁存器的电路图和版图。</h3><h3 id="74：用filp-flop和logic-gate设计一个1位加法器，输入carryin和current-stage，输出carryout和next-stage"><a href="#74：用filp-flop和logic-gate设计一个1位加法器，输入carryin和current-stage，输出carryout和next-stage" class="headerlink" title="74：用filp-flop和logic-gate设计一个1位加法器，输入carryin和current-stage，输出carryout和next-stage."></a>74：用filp-flop和logic-gate设计一个1位加法器，输入carryin和current-stage，输出carryout和next-stage.</h3><h3 id="75：用D触发器做个4进制的计数。"><a href="#75：用D触发器做个4进制的计数。" class="headerlink" title="75：用D触发器做个4进制的计数。"></a>75：用D触发器做个4进制的计数。</h3><p>按照时序逻辑电路的设计步骤来：</p>
<p>1、写出状态转换表</p>
<p>2、寄存器的个数确定</p>
<p>3、状态编码</p>
<p>4、卡诺图化简</p>
<p>5、状态方程，驱动方程等</p>
<h3 id="76：实现N位Johnson-Counter-N-5。"><a href="#76：实现N位Johnson-Counter-N-5。" class="headerlink" title="76：实现N位Johnson Counter, N=5。"></a>76：实现N位Johnson Counter, N=5。</h3><h3 id="78：数字电路设计当然必问Verilog-VHDL，如设计计数器。"><a href="#78：数字电路设计当然必问Verilog-VHDL，如设计计数器。" class="headerlink" title="78：数字电路设计当然必问Verilog/VHDL，如设计计数器。"></a>78：数字电路设计当然必问Verilog/VHDL，如设计计数器。</h3><h3 id="79：请用HDL描述四位的全加法器、5分频电路。"><a href="#79：请用HDL描述四位的全加法器、5分频电路。" class="headerlink" title="79：请用HDL描述四位的全加法器、5分频电路。"></a>79：请用HDL描述四位的全加法器、5分频电路。</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"> 	</span><br><span class="line"><span class="keyword">module</span> adder4(a,b,ci,s,co);</span><br><span class="line">    <span class="keyword">input</span> ci;</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] a,b;</span><br><span class="line">    <span class="keyword">output</span> co;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] s;</span><br><span class="line">    <span class="keyword">assign</span> &#123;co,s&#125;=a+b+ci;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">module</span> div5(clk,rst,clk_out);</span><br><span class="line">    <span class="keyword">input</span> clk,rst;</span><br><span class="line">    <span class="keyword">output</span> clk_out;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] count;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!rst)</span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">            count&lt;=<span class="number">0</span>;</span><br><span class="line">            clk_out=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(count==<span class="number">3</span>’d5)</span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">            count&lt;=<span class="number">0</span>;</span><br><span class="line">            clk_out=~clk_out;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            count&lt;=count+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//实现奇数倍分频且占空比为50%的情况：</span></span><br><span class="line"><span class="keyword">module</span> div7 ( clk, reset_n, clkout );</span><br><span class="line">    <span class="keyword">input</span> clk,reset_n;</span><br><span class="line">    <span class="keyword">output</span> clkout;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] count;</span><br><span class="line">    <span class="keyword">reg</span> div1;</span><br><span class="line">    <span class="keyword">reg</span> div2;</span><br><span class="line">    <span class="keyword">always</span> @( <span class="keyword">posedge</span> clk )</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> ( ! reset_n )</span><br><span class="line">        count &lt;= <span class="number">3'b000</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">case</span> ( count )</span><br><span class="line">        <span class="number">3'b000</span> : count &lt;=<span class="number">3'b001</span>;</span><br><span class="line">        <span class="number">3'b001</span> : count &lt;=<span class="number">3'b010</span>;</span><br><span class="line">        <span class="number">3'b010</span> : count &lt;=<span class="number">3'b011</span>;</span><br><span class="line">        <span class="number">3'b011</span> : count &lt;=<span class="number">3'b100</span>;</span><br><span class="line">        <span class="number">3'b100</span> : count &lt;=<span class="number">3'b101</span>;</span><br><span class="line">        <span class="number">3'b101</span> : count &lt;=<span class="number">3'b110</span>;</span><br><span class="line">        <span class="number">3'b110</span> : count &lt;=<span class="number">3'b000</span>;</span><br><span class="line">        <span class="keyword">default</span> :</span><br><span class="line">        count &lt;= <span class="number">3'b000</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span> @( <span class="keyword">posedge</span> clk )</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> ( ! reset_n )</span><br><span class="line">        div1 &lt;= <span class="number">1'b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( count == <span class="number">3'b000</span> )</span><br><span class="line">        div1 &lt;= ~ div1;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span> @( <span class="keyword">negedge</span> clk )</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> ( ! reset_n )</span><br><span class="line">        div2 &lt;= <span class="number">1'b0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( count == <span class="number">3'b100</span> )</span><br><span class="line">        div2 &lt;= ~ div2;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">assign</span> clkout = div1 ^ div2;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="80：用VERILOG或VHDL写一段代码，实现10进制计数器。"><a href="#80：用VERILOG或VHDL写一段代码，实现10进制计数器。" class="headerlink" title="80：用VERILOG或VHDL写一段代码，实现10进制计数器。"></a>80：用VERILOG或VHDL写一段代码，实现10进制计数器。</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> counter10(clk,rst,count);</span><br><span class="line">    <span class="keyword">input</span> clk,rst;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] count;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] count;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!rst)</span><br><span class="line">            count&lt;=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(count&gt;=<span class="number">4</span>’d9)</span><br><span class="line">            count&lt;=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            count&lt;=count+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>     
<h3 id="81：描述一个交通信号灯的设计。"><a href="#81：描述一个交通信号灯的设计。" class="headerlink" title="81：描述一个交通信号灯的设计。"></a>81：描述一个交通信号灯的设计。</h3><h3 id="82：画状态机，接受1，2，5分钱的卖报机，每份报纸5分钱。"><a href="#82：画状态机，接受1，2，5分钱的卖报机，每份报纸5分钱。" class="headerlink" title="82：画状态机，接受1，2，5分钱的卖报机，每份报纸5分钱。"></a>82：画状态机，接受1，2，5分钱的卖报机，每份报纸5分钱。</h3><p>1、确定输入输出，投1分钱A=1，投2分钱B=1，投5分钱C=1，给出报纸Y=1</p>
<p>2、确定状态数画出状态转移图，没有投币之前的初始状态S0，投入了1分硬币S1，投入了2分硬币S2，投入了3分硬币S3，投入了4分硬币S4。</p>
<p>3、画卡诺图或者是利用verilog编码</p>
<h3 id="83：设计一个自动售货机系统，卖soda水的，只能投进三种硬币，要正确的找回钱数。"><a href="#83：设计一个自动售货机系统，卖soda水的，只能投进三种硬币，要正确的找回钱数。" class="headerlink" title="83：设计一个自动售货机系统，卖soda水的，只能投进三种硬币，要正确的找回钱数。"></a>83：设计一个自动售货机系统，卖soda水的，只能投进三种硬币，要正确的找回钱数。</h3><p>（1）画出fsm（有限状态机）；（2）用verilog编程，语法要符合fpga设计的要求。</p>
<h3 id="84：设计一个自动饮料售卖机，饮料10分钱，硬币有5分和10分两种，并考虑找零：（1）画出fsm（有限状态机）；（2）用verilog编程，语法要符合fpga设计的要求；（3）设计工程中可使用的工具及设计大致过程。"><a href="#84：设计一个自动饮料售卖机，饮料10分钱，硬币有5分和10分两种，并考虑找零：（1）画出fsm（有限状态机）；（2）用verilog编程，语法要符合fpga设计的要求；（3）设计工程中可使用的工具及设计大致过程。" class="headerlink" title="84：设计一个自动饮料售卖机，饮料10分钱，硬币有5分和10分两种，并考虑找零：（1）画出fsm（有限状态机）；（2）用verilog编程，语法要符合fpga设计的要求；（3）设计工程中可使用的工具及设计大致过程。"></a>84：设计一个自动饮料售卖机，饮料10分钱，硬币有5分和10分两种，并考虑找零：（1）画出fsm（有限状态机）；（2）用verilog编程，语法要符合fpga设计的要求；（3）设计工程中可使用的工具及设计大致过程。</h3><p>1、输入A=1表示投5分钱，B=1表示投10分钱，输出Y=1表示给饮料，Z=1表示找零</p>
<p>2、确定状态数，没投币之前S0，投入了5分S1</p>
<h3 id="85：画出可以检测10010串的状态图-并verilog实现之。"><a href="#85：画出可以检测10010串的状态图-并verilog实现之。" class="headerlink" title="85：画出可以检测10010串的状态图,并verilog实现之。"></a>85：画出可以检测10010串的状态图,并verilog实现之。</h3><p>1、输入data，1和0两种情况，输出Y=1表示连续输入了10010</p>
<p>2、确定状态数没输入之前S0，输入一个0到了S1,10为S2,010为S3,0010为S4</p>
<h3 id="86：用FSM实现101101的序列检测模块。"><a href="#86：用FSM实现101101的序列检测模块。" class="headerlink" title="86：用FSM实现101101的序列检测模块。"></a>86：用FSM实现101101的序列检测模块。</h3><p>a为输入端，b为输出端，如果a连续输入为101101则b输出为1，否则为0。<br>例如 a： 0001100110110110100110<br>b： 0000000000100100000000<br>请画出state machine；请用RTL描述其state machine。</p>
<p>确定状态数，没有输入或输入0为S0，1为S1，01为S2,101为S3,1101为S4，01101为S5。知道了输入输出和状态转移的关系很容易写出状态机的verilog代码，一般采用两段式状态机</p>
<h3 id="87：给出单管DRAM的原理图"><a href="#87：给出单管DRAM的原理图" class="headerlink" title="87：给出单管DRAM的原理图"></a>87：给出单管DRAM的原理图</h3><p>参考数字集成电路相关书籍</p>
<h3 id="88：什么叫做OTP片-OTP（一次性可编程）-、掩膜片，两者的区别何在？"><a href="#88：什么叫做OTP片-OTP（一次性可编程）-、掩膜片，两者的区别何在？" class="headerlink" title="88：什么叫做OTP片(OTP（一次性可编程）)、掩膜片，两者的区别何在？"></a>88：什么叫做OTP片(OTP（一次性可编程）)、掩膜片，两者的区别何在？</h3><h3 id="89：你知道的集成电路设计的方式有哪几种？"><a href="#89：你知道的集成电路设计的方式有哪几种？" class="headerlink" title="89：你知道的集成电路设计的方式有哪几种？"></a>89：你知道的集成电路设计的方式有哪几种？</h3><h3 id="90：描述你对集成电路设计流程的认识。"><a href="#90：描述你对集成电路设计流程的认识。" class="headerlink" title="90：描述你对集成电路设计流程的认识。"></a>90：描述你对集成电路设计流程的认识。</h3><h3 id="91：描述你对集成电路工艺的认识。"><a href="#91：描述你对集成电路工艺的认识。" class="headerlink" title="91：描述你对集成电路工艺的认识。"></a>91：描述你对集成电路工艺的认识。</h3><p>工艺分类：TTL，CMOS两种比较流行，TTL速度快功耗高，CMOS速度慢功耗低。</p>
<p>集成电路的工艺主要是指CMOS电路的制造工艺，主要分为以下几个步骤：衬底准备-氧化、光刻-扩散和离子注入-淀积-刻蚀-平面化。</p>
<h3 id="92：简述FPGA等可编程逻辑器件设计流程。"><a href="#92：简述FPGA等可编程逻辑器件设计流程。" class="headerlink" title="92：简述FPGA等可编程逻辑器件设计流程。"></a>92：简述FPGA等可编程逻辑器件设计流程。</h3><p>通常可将FPGA/CPLD设计流程归纳为以下7个步骤，这与ASIC设计有相似之处。</p>
<p>1.设计输入。Verilog或VHDL编写代码。</p>
<p>2.前仿真（功能仿真）。设计的电路必须在布局布线前验证电路功能是否有效。（ASCI设计中，这一步骤称为第一次Sign-off）PLD设计中，有时跳过这一步。</p>
<p>3.设计编译（综合）。设计输入之后就有一个从高层次系统行为设计向门级逻辑电路设转化翻译过程，即把设计输入的某种或某几种数据格式(网表)转化为软件可识别的某种数据格式(网表)。</p>
<p>4.优化。对于上述综合生成的网表，根据布尔方程功能等效的原则，用更小更快的综合结果代替一些复杂的单元，并与指定的库映射生成新的网表，这是减小电路规模的一条必由之路。</p>
<p>5.布局布线。</p>
<p>6.后仿真（时序仿真）需要利用在布局布线中获得的精确参数再次验证电路的时序。（ASCI设计中，这一步骤称为第二次Sign—off）。</p>
<p>7.生产。布线和后仿真完成之后，就可以开始ASCI或PLD芯片的投产</p>
<h3 id="93：分别写出IC设计前端到后端的流程和eda工具。"><a href="#93：分别写出IC设计前端到后端的流程和eda工具。" class="headerlink" title="93：分别写出IC设计前端到后端的流程和eda工具。"></a>93：分别写出IC设计前端到后端的流程和eda工具。</h3><p>逻辑设计–子功能分解–详细时序框图–分块逻辑仿真–电路设计(RTL级描述)–功能仿真–综合(加时序约束和设计库)–电路网表–网表仿真)-预布局布线(SDF文件)–网表仿真(带延时文件)–静态时序分析–布局布线–参数提取–SDF文件–后仿真–静态时序分析–测试向量生成–工艺设计与生产–芯片测试–芯片应用，在验证过程中出现的时序收敛，功耗，面积问题，应返回前端的代码输入进行重新修改，再仿真，再综合，再验证，一般都要反复好几次才能最后送去foundry厂流片。设计公司是fabless</p>
<p>数字IC设计流程（zz）</p>
<p>1.需求分析(制定规格书)。分析用户或市场的需求，并将其翻译成对芯片产品的技术需求。</p>
<p>2.算法设计。设计和优化芯片钟所使用的算法。这一阶段一般使用高级编程语言（如C/C++），利用算法级建模和仿真工具（如MATLAB，SPW）进行浮点和定点的仿真，进而对算法进行评估和优化。</p>
<p>3.构架设计。根据设计的功能需求和算法分析的结果，设计芯片的构架，并对不同的方案进行比较，选择性能价格最优的方案。这一阶段可以使用SystemC语言对芯片构架进行模拟和分析。</p>
<p>4.RTL设计（代码输入）。使用HDL语言完成对设计实体的RTL级描述。这一阶段使用VHDL和Verilog HDL语言的输入工具编写代码。</p>
<ol start="5">
<li>RTL验证（功能仿真）。使用仿真工具或其他RTL代码分析工具，验证RTL代码的质量和性能。</li>
</ol>
<p>6.综合。从RTL代码生成描述实际电路的门级网表文件。</p>
<p>7.门级验证（综合后仿真）。对综合产生的门级网表进行验证。这一阶段通常会使用仿真、静态时序分析和形式验证等工具。</p>
<ol start="8">
<li>布局布线。后端设计对综合产生的门级网表进行布局规划（Floorplanning）、布局（Placement）、布线（Routing），生成生产用的版图。</li>
</ol>
<p>9.电路参数提取确定芯片中互连线的寄生参数，从而获得门级的延时信息。</p>
<p>10.版图后验证。根据后端设计后取得的新的延时信息，再次验证设计是否能够实现所有的功能和性能指标。</p>
<p>11.芯片生产。生产在特定的芯片工艺线上制造出芯片。</p>
<ol start="12">
<li>芯片测试。对制造好的芯片进行测试，检测生产中产生的缺陷和问题。</li>
</ol>
<p>数字IC后端设计流程</p>
<ol>
<li>数据准备。对于 Cadance的 SE而言后端设计所需的数据主要有是Foundry厂提供的标准单元、宏单元和I/O Pad的库文件,它包括物理库、时序库及网表库,分别以.lef、.tlf和.v的形式给出。前端的芯片设计经过综合后生成的门级网表,具有时序约束和时钟定义的脚本文件和由此产生的.gcf约束文件以及定义电源Pad的DEF（Design Exchange Format）文件。(对synopsys 的Astro 而言, 经过综合后生成的门级网表,时序约束文件 SDC 是一样的,Pad的定义文件–tdf , .tf 文件 –technology file, Foundry厂提供的标准单元、宏单元和I/O Pad的库文件就与FRAM, CELL view, LM view 形式给出(Milkway 参考库 and DB, LIB file)</li>
</ol>
<p>2.布局规划。主要是标准单元、I/O Pad和宏单元的布局。I/O Pad预先给出了位置,而宏单元则根据时序要求进行摆放,标准单元则是给出了一定的区域由工具自动摆放。布局规划后,芯片的大小,Core的面积,Row的形式、电源及地线的Ring和Strip都确定下来了。如果必要在自动放置标准单元和宏单元之后, 你可以先做一次PNA(power network analysis）–IR drop and EM .</p>
<ol start="3">
<li><p>Placement -自动放置标准单元。布局规划后,宏单元、I/O Pad的位置和放置标准单元的区域都已确定,这些信息SE（Silicon Ensemble）会通过DEF文件传递给PC(Physical Compiler),PC根据由综合给出的.DB文件获得网表和时序约束信息进行自动放置标准单元,同时进行时序检查和单元放置优化。如果你用的是PC +Astro那你可用write_milkway, read_milkway传递数据。</p>
</li>
<li><p>时钟树生成(CTS Clock tree synthesis)。芯片中的时钟网络要驱动电路中所有的时序单元,所以时钟源端门单元带载很多,其负载延时很大并且不平衡,需要插入缓冲器减小负载和平衡延时。时钟网络及其上的缓冲器构成了时钟树。一般要反复几次才可以做出一个比较理想的时钟树。</p>
</li>
<li><p>STA静态时序分析和后仿真。时钟树插入后,每个单元的位置都确定下来了,工具可以提出Global Route形式的连线寄生参数,此时对延时参数的提取就比较准确了。SE把.V和.SDF文件传递给PrimeTime做静态时序分析。确认没有时序违规后,将这来两个文件传递给前端人员做后仿真。对Astro 而言,在detail routing 之后, 用starRC XT参数提取,生成的E.V和.SDF文件传递给PrimeTime做静态时序分析,那将会更准确。</p>
</li>
<li><p>ECO(Engineering Change Order)。针对静态时序分析和后仿真中出现的问题,对电路和单元布局进行小范围的改动.</p>
</li>
<li><p>filler的插入(pad fliier, cell filler)。Filler指的是标准单元库和I/O Pad库中定义的与逻辑无关的填充物,用来填充标准单元和标准单元之间,I/O Pad和I/O Pad之间的间隙,它主要是把扩散层连接起来,满足DRC规则和设计需要。</p>
</li>
</ol>
<p>8.布线(Routing)。Global route– Track assign –Detail routing—Routing optimization布线是指在满足工艺规则和布线层数限制、线宽、线间距限制和各线网可靠绝缘的电性能约束的条件下,根据电路的连接关系将各单元和I/O Pad用互连线连接起来,这些是在时序驱动(Timing driven ) 的条件下进行的,保证关键时序路径上的连线长度能够最小。–Timing report clear</p>
<ol start="9">
<li><p>Dummy Metal的增加。Foundry厂都有对金属密度的规定,使其金属密度不要低于一定的值,以防在芯片制造过程中的刻蚀阶段对连线的金属层过度刻蚀从而降低电路的性能。加入Dummy Metal是为了增加金属的密度。</p>
</li>
<li><p>DRC和LVS。DRC是对芯片版图中的各层物理图形进行设计规则检查(spacing ,width),它也包括天线效应的检查,以确保芯片正常流片。LVS主要是将版图和电路网表进行比较,来保证流片出来的版图电路和实际需要的电路一致。DRC和LVS的检查–EDA工具Synopsy hercules/ mentor calibre/ CDN Dracula进行的.Astro also include LVS/DRC check commands.</p>
</li>
<li><p>Tape out。在所有检查和验证都正确无误的情况下把最后的版图GDSⅡ文件传递给Foundry厂进行掩膜制造    </p>
<h3 id="94：从RTL-synthesis到tape-out之间的设计flow-并列出其中各步使用的tool"><a href="#94：从RTL-synthesis到tape-out之间的设计flow-并列出其中各步使用的tool" class="headerlink" title="94：从RTL synthesis到tape out之间的设计flow,并列出其中各步使用的tool."></a>94：从RTL synthesis到tape out之间的设计flow,并列出其中各步使用的tool.</h3><p>FLOW ：综合-布局布线-时序仿真-时序分析 TOOLS：略</p>
<h3 id="95：是否接触过自动布局布线？请说出一两种工具软件。自动布局布线需要哪些基本元素？"><a href="#95：是否接触过自动布局布线？请说出一两种工具软件。自动布局布线需要哪些基本元素？" class="headerlink" title="95：是否接触过自动布局布线？请说出一两种工具软件。自动布局布线需要哪些基本元素？"></a>95：是否接触过自动布局布线？请说出一两种工具软件。自动布局布线需要哪些基本元素？</h3><p>自动布局布线其基本流程如下：</p>
</li>
</ol>
<p>1、读入网表，跟foundry提供的标准单元库和Pad库以及宏模块库进行映射；<br>2、整体布局，规定了芯片的大致面积和管脚位置以及宏单元位置等粗略的信息；<br>3、读入时序约束文件，设置好timing setup菜单，为后面进行时序驱动的布局布线做准备；<br>4、详细布局，力求使后面布线能顺利满足布线布通率100%的要求和时序的要求；<br>5、时钟树综合，为了降低clock skew而产生由许多buffer单元组成的“时钟树”；<br>6、布线，先对电源线和时钟信号布线，然后对信号线布线，目标是最大程度地满足时序；<br>7、为满足design rule从而foundry能成功制造出该芯片而做的修补工作，如填充一些dummy等。<br>常用的工具有Synopsys的ASTRO，Cadence的SE，ISE，Quartus II也可实现布局布线。    </p>
<h3 id="96：列举几种集成电路典型工艺。工艺上常提到0-25-0-18指的是什么？"><a href="#96：列举几种集成电路典型工艺。工艺上常提到0-25-0-18指的是什么？" class="headerlink" title="96：列举几种集成电路典型工艺。工艺上常提到0.25,0.18指的是什么？"></a>96：列举几种集成电路典型工艺。工艺上常提到0.25,0.18指的是什么？</h3><h3 id="97：请描述一下国内的工艺现状。"><a href="#97：请描述一下国内的工艺现状。" class="headerlink" title="97：请描述一下国内的工艺现状。"></a>97：请描述一下国内的工艺现状。</h3><h3 id="98：半导体工艺中，掺杂有哪几种方式？"><a href="#98：半导体工艺中，掺杂有哪几种方式？" class="headerlink" title="98：半导体工艺中，掺杂有哪几种方式？"></a>98：半导体工艺中，掺杂有哪几种方式？</h3><h3 id="99：描述CMOS电路中闩锁效应产生的过程及最后的结果？"><a href="#99：描述CMOS电路中闩锁效应产生的过程及最后的结果？" class="headerlink" title="99：描述CMOS电路中闩锁效应产生的过程及最后的结果？"></a>99：描述CMOS电路中闩锁效应产生的过程及最后的结果？</h3><p>闩锁效应是CMOS工艺所特有的寄生效应，严重会导致电路的失效，甚至烧毁芯片。闩锁效应是由NMOS的有源区、P衬底、N阱、PMOS的有源区构成的n-p-n-p结构产生的，当其中一个三极管正偏时，就会构成正反馈形成闩锁。避免闩锁的方法就是要减小衬底和N阱的寄生电阻，使寄生的三极管不会处于正偏状态。静电是一种看不见的破坏力，会对电子元器件产生影响。ESD 和相关的电压瞬变都会引起闩锁效应（latch-up）是半导体器件失效的主要原因之一。如果有一个强电场施加在器件结构中的氧化物薄膜上，则该氧化物薄膜就会因介质击穿而损坏。很细的金属化迹线会由于大电流而损坏，并会由于浪涌电流造成的过热而形成开路。这就是所谓的“闩锁效应”。在闩锁情况下，器件在电源与地之间形成短路，造成大电流、EOS（电过载）和器件损坏。</p>
<h3 id="100：解释latch-up现象和Antenna-effect及其预防措施。"><a href="#100：解释latch-up现象和Antenna-effect及其预防措施。" class="headerlink" title="100：解释latch-up现象和Antenna effect及其预防措施。"></a>100：解释latch-up现象和Antenna effect及其预防措施。</h3><p>在芯片生产过程中，暴露的金属线或者多晶硅(polysilicon)等导体，就象是一根根天线，会收集电荷（如等离子刻蚀产生的带电粒子）导致电位升高。天线越长，收集的电荷也就越多，电压就越高。若这片导体碰巧只接了MOS 的栅，那么高电压就可能把薄栅氧化层击穿，使电路失效，这种现象我们称之为“天线效应”。随着工艺技术的发展，栅的尺寸越来越小，金属的层数越来越多，发生天线效应的可能性就越大</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mike-rush.github.io/2020/05/13/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80100%E9%A2%98P2/" data-id="cka4sxnvj0000hor2ep8t1s6f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/05/12/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80100%E9%A2%98P1/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">数字IC设计基础知识100题（Part I）</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/05/13/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80100%E9%A2%98P2/">数字IC设计基础知识100题（Part II）</a>
          </li>
        
          <li>
            <a href="/2020/05/12/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80100%E9%A2%98P1/">数字IC设计基础知识100题（Part I）</a>
          </li>
        
          <li>
            <a href="/2020/05/11/%E6%97%B6%E9%92%9F%E5%88%87%E6%8D%A2%E4%B8%AD%E7%9A%84glitch/">时钟切换中的glitch</a>
          </li>
        
          <li>
            <a href="/2020/05/11/PCB%E5%90%8D%E7%89%87%E9%A1%B9%E7%9B%AE%E2%80%94%E6%9E%84%E6%83%B3/">PCB名片项目—构想</a>
          </li>
        
          <li>
            <a href="/2020/05/11/MC-0-5um-PDK/">CSMC 0.5um PDK</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Mike Rush<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>