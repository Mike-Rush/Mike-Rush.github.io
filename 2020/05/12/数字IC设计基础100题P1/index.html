<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>数字IC设计基础知识100题（Part I） | Mike Rush&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="转载不必注明出处，就说是你自己写的">
<meta property="og:type" content="article">
<meta property="og:title" content="数字IC设计基础知识100题（Part I）">
<meta property="og:url" content="https://mike-rush.github.io/2020/05/12/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80100%E9%A2%98P1/index.html">
<meta property="og:site_name" content="Mike Rush&#39;s Blog">
<meta property="og:description" content="转载不必注明出处，就说是你自己写的">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-05-12T03:25:10.000Z">
<meta property="article:modified_time" content="2020-05-12T04:00:44.825Z">
<meta property="article:author" content="Mike Rush">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Mike Rush&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Mike Rush&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://Mike-Rush.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-数字IC设计基础100题P1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/12/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80100%E9%A2%98P1/" class="article-date">
  <time datetime="2020-05-12T03:25:10.000Z" itemprop="datePublished">2020-05-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      数字IC设计基础知识100题（Part I）
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>转载不必注明出处，就说是你自己写的</p>
<a id="more"></a>
<h3 id="1：什么是同步逻辑和异步逻辑？"><a href="#1：什么是同步逻辑和异步逻辑？" class="headerlink" title="1：什么是同步逻辑和异步逻辑？"></a>1：什么是同步逻辑和异步逻辑？</h3><p>  同步逻辑是时钟之间有固定的因果关系。异步逻辑是各时钟之间没有固定的因果关系。</p>
<p>  同步时序逻辑电路的特点：各触发器的时钟端全部连接在一起，并接在系统时钟端，只有当时钟脉冲到来时，电路的状态才能改变。改变后的状态将一直保持到下一个时钟脉冲的到来，此时无论外部输入x有无变化，状态表中的每个状态都是稳定的。</p>
<p>  异步时序逻辑电路的特点：电路中除可以使用带时钟的触发器外，还可以使用不带时钟的触发器和延迟元件作为存储元件，电路中没有统一的时钟，电路状态的改变由外部输入的变化直接引起。</p>
<h3 id="2：同步电路和异步电路的区别"><a href="#2：同步电路和异步电路的区别" class="headerlink" title="2：同步电路和异步电路的区别?"></a>2：同步电路和异步电路的区别?</h3><p>  同步电路：存储电路中所有触发器的时钟输入端都接同一个时钟脉冲源，因而所有触发器的状态的变化都与所加的时钟脉冲信号同步。</p>
<p>  异步电路：电路没有统一的时钟，有些触发器的时钟输入端与时钟脉冲源相连，只有这些触发器的状态变化与时钟脉冲同步，而其他的触发器的状态变化不与时钟脉冲同步。</p>
<h3 id="3：时序设计的实质"><a href="#3：时序设计的实质" class="headerlink" title="3：时序设计的实质?"></a>3：时序设计的实质?</h3><p>  时序设计的实质就是满足每一个触发器的建立/保持时间的要求。</p>
<h3 id="4：建立时间与保持时间的概念？"><a href="#4：建立时间与保持时间的概念？" class="headerlink" title="4：建立时间与保持时间的概念？"></a>4：建立时间与保持时间的概念？</h3><p>建立时间：触发器在时钟上升沿到来之前，其数据输入端的数据必须保持不变的最小时间。</p>
<p>保持时间：触发器在时钟上升沿到来之后，其数据输入端的数据必须保持不变的最小时间。</p>
<h3 id="5：为什么触发器要满足建立时间和保持时间？"><a href="#5：为什么触发器要满足建立时间和保持时间？" class="headerlink" title="5：为什么触发器要满足建立时间和保持时间？"></a>5：为什么触发器要满足建立时间和保持时间？</h3><p>因为触发器内部数据的形成是需要一定的时间的，如果不满足建立和保持时间，触发器将进入亚稳态，进入亚稳态后触发器的输出将不稳定，在0和1之间变化，这时需要经过一个恢复时间，其输出才能稳定，但稳定后的值并不一定是你的输入值。这就是为什么要用两级触发器来同步异步输入信号。这样做可以防止由于异步输入信号对于本级时钟可能不满足建立保持时间而使本级触发器产生的亚稳态传播到后面逻辑中，导致亚稳态的传播。</p>
<p>（比较容易理解的方式）换个方式理解：需要建立时间是因为触发器的D端像一个锁存器在接受数据，为了稳定的设置前级门的状态需要一段稳定时间；需要保持时间是因为在时钟沿到来之后，触发器要通过反馈来锁存状态，从后级门传到前级门需要时间。</p>
<h3 id="6：什么是亚稳态？为什么两级触发器可以防止亚稳态传播？"><a href="#6：什么是亚稳态？为什么两级触发器可以防止亚稳态传播？" class="headerlink" title="6：什么是亚稳态？为什么两级触发器可以防止亚稳态传播？"></a>6：什么是亚稳态？为什么两级触发器可以防止亚稳态传播？</h3><p>这也是一个异步电路同步化的问题。亚稳态是指触发器无法在某个规定的时间段内到达一个可以确认的状态。使用两级触发器来使异步电路同步化的电路其实叫做“一位同步器”，他只能用来对一位异步信号进行同步。两级触发器可防止亚稳态传播的原理：假 设第一级触发器的输入不满足其建立保持时间，它在第一个脉冲沿到来后输出的数据就为亚稳态，那么在下一个脉冲沿到来之前，其输出的亚稳态数据在一段恢复时 间后必须稳定下来，而且稳定的数据必须满足第二级触发器的建立时间，如果都满足了，在下一个脉冲沿到来时，第二级触发器将不会出现亚稳态，因为其输入端的 数据满足其建立保持时间。同步器有效的条件：第一级触发器进入亚稳态后的恢复时间 + 第二级触发器的建立时间 &lt; = 时钟周期。</p>
<p>更确切地说，输入脉冲宽度必须大于同步时钟周期与第一级触发器所需的保持时间之和。最保险的脉冲宽度是两倍同步时钟周期。所以，这样的同步电路对于从较慢的时钟域来的异步信号进入较快的时钟域比较有效，对于进入一个较慢的时钟域，则没有作用。</p>
<h3 id="7：系统最高速度计算（最快时钟频率）和流水线设计思想"><a href="#7：系统最高速度计算（最快时钟频率）和流水线设计思想" class="headerlink" title="7：系统最高速度计算（最快时钟频率）和流水线设计思想?"></a>7：系统最高速度计算（最快时钟频率）和流水线设计思想?</h3><p>同步电路的速度是指同步系统时钟的速度，同步时钟愈快，电路处理数据的时间间隔越短，电路在单位时间内处理的数据量就愈大。假设Tco是触发器的输入数据被时钟打入到触发器到数据到达触发器输出端的延时时间(Tco=Tsetpup+Thold)；Tdelay是组合逻辑的延时；Tsetup是Ｄ触发器的建立时间。假设数据已被时钟打入D触发器，那么数据到达第一个触发器的Ｑ输出端需要的延时时间是Tco，经过组合逻辑的延时时间为Tdelay，然后到达第二个触发器的Ｄ端，要希望时钟能在第二个触发器再次被稳定地打入触发器，则时钟的延迟必须大于Tco＋Tdelay＋Tsetup，也就是说最小的时钟周期Tmin =Tco＋Tdelay＋Tsetup，即最快的时钟频率Fmax =1/Tmin。FPGA开发软件也是通过这种方法来计算系统最高运行速度Fmax。因为Tco和Tsetup是由具体的器件工艺决定的，故设计电路时只能改变组合逻辑的延迟时间Tdelay，所以说缩短触发器间组合逻辑的延时时间是提高同步电路速度的关键所在。由于一般同步电路都大于一级锁存，而要使电路稳定工作，时钟周期必须满足最大延时要求。故只有缩短最长延时路径，才能提高电路的工作频率。可以将较大的组合逻辑分解为较小的N块，通过适当的方法平均分配组合逻辑，然后在中间插入触发器，并和原触发器使用相同的时钟，就可以避免在两个触发器之间出现过大的延时，消除速度瓶颈，这样可以提高电路的工作频率。这就是所谓”流水线”技术的基本设计思想，即原设计速度受限部分用一个时钟周期实现，采用流水线技术插入触发器后，可用N个时钟周期实现，因此系统的工作速度可以加快，吞吐量加大。注意，流水线设计会在原数据通路上加入延时，另外硬件面积也会稍有增加。</p>
<h3 id="8：时序约束的概念和基本策略？"><a href="#8：时序约束的概念和基本策略？" class="headerlink" title="8：时序约束的概念和基本策略？"></a>8：时序约束的概念和基本策略？</h3><p>时序约束主要包括周期约束，偏移约束，静态时序路径约束三种。通过附加时序约束可以综合布线工具调整映射和布局布线，使设计达到时序要求。</p>
<p>附加时序约束的一般策略是先附加全局约束，然后对快速和慢速例外路径附加专门约束。附加全局约束时，首先定义设计的所有时钟，对各时钟域内的同步元件进行分组，对分组附加周期约束，然后对FPGA/CPLD输入输出PAD附加偏移约束、对全组合逻辑的PAD TO PAD路径附加约束。附加专门约束时，首先约束分组之间的路径，然后约束快、慢速例外路径和多周期路径，以及其他特殊路径。</p>
<h3 id="9：附加约束的作用？"><a href="#9：附加约束的作用？" class="headerlink" title="9：附加约束的作用？"></a>9：附加约束的作用？</h3><p>1：提高设计的工作频率（减少了逻辑和布线延时）；<br>2：获得正确的时序分析报告；（静态时序分析工具以约束作为判断时序是否满足设计要求的标准，因此要求设计者正确输入约束，以便静态时序分析工具可以正确的输出时序报告）<br>3：指定FPGA/CPLD的电气标准和引脚位置。</p>
<h3 id="10：FPGA设计工程师努力的方向？"><a href="#10：FPGA设计工程师努力的方向？" class="headerlink" title="10：FPGA设计工程师努力的方向？"></a>10：FPGA设计工程师努力的方向？</h3><p>SOPC，高速串行I/O，低功耗，可靠性，可测试性和设计验证流程的优化等方面。</p>
<p>随着芯片工艺的提高，芯片容量、集成度都在增加，FPGA设计也朝着高速、高度集成、低功耗、高可靠性、高可测、可验证性发展。芯片可测、可验证，正在成为复杂设计所必备的条件，尽量在上板之前查出bug，将发现bug的时间提前，这也是一些公司花大力气设计仿真平台的原因。另外随着单板功能的提高、成本的压力，低功耗也逐渐进入FPGA设计者的考虑范围，完成相同的功能下，考虑如何能够使芯片的功耗最低，据说altera、xilinx都在根据自己的芯片特点整理如何降低功耗的文档。高速串行IO的应用，也丰富了FPGA的应用范围，像xilinx的v2pro中的高速链路也逐渐被应用。</p>
<h3 id="11：对于多位的异步信号如何进行同步？"><a href="#11：对于多位的异步信号如何进行同步？" class="headerlink" title="11：对于多位的异步信号如何进行同步？"></a>11：对于多位的异步信号如何进行同步？</h3><p>对以一位的异步信号可以使用“一位同步器进行同步”（使用两级触发器），而对于多位的异步信号，可以采用如下方法：<br>1：可以采用保持寄存器加握手信号的方法（多数据，控制，地址）；<br>2：特殊的具体应用电路结构,根据应用的不同而不同；<br>3：异步FIFO。（最常用的缓存单元是DPRAM）</p>
<h3 id="12：FPGA和CPLD的区别？"><a href="#12：FPGA和CPLD的区别？" class="headerlink" title="12：FPGA和CPLD的区别？"></a>12：FPGA和CPLD的区别？</h3><table>
<thead>
<tr>
<th>特点</th>
<th>FPGA</th>
<th>CPLD</th>
</tr>
</thead>
<tbody><tr>
<td>内部结构</td>
<td>Product term（基于乘积项）</td>
<td>Look up Table（基于查找表）</td>
</tr>
<tr>
<td>程序存储</td>
<td>内部EEPROM/FLASH</td>
<td>SRAM，外挂EEPROM</td>
</tr>
<tr>
<td>资源类型</td>
<td>组合逻辑资源丰富</td>
<td>时序逻辑资源丰富</td>
</tr>
<tr>
<td>集成度</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>使用场合</td>
<td>完成控制逻辑</td>
<td>能完成比较复杂的算法</td>
</tr>
<tr>
<td>速度</td>
<td>慢</td>
<td>快 ？？</td>
</tr>
<tr>
<td>其他资源</td>
<td>－</td>
<td>PLL、RAM和乘法器等</td>
</tr>
<tr>
<td>保密性</td>
<td>可加密</td>
<td>一般不能保密</td>
</tr>
</tbody></table>
<h3 id="13：锁存器（latch）和触发器（flip-flop）区别？"><a href="#13：锁存器（latch）和触发器（flip-flop）区别？" class="headerlink" title="13：锁存器（latch）和触发器（flip-flop）区别？"></a>13：锁存器（latch）和触发器（flip-flop）区别？</h3><p>电平敏感的存储器件称为锁存器。可分为高电平锁存器和低电平锁存器，用于不同时钟之间的信号同步。</p>
<p>有交叉耦合的门构成的双稳态的存储原件称为触发器。分为上升沿触发和下降沿触发。可以认为是两个不同电平敏感的锁存器串连而成。前一个锁存器决定了触发器的建立时间，后一个锁存器则决定了保持时间。</p>
<h3 id="14：FPGA芯片内有哪两种存储器资源？"><a href="#14：FPGA芯片内有哪两种存储器资源？" class="headerlink" title="14：FPGA芯片内有哪两种存储器资源？"></a>14：FPGA芯片内有哪两种存储器资源？</h3><p>FPGA芯片内有两种存储器资源：一种叫BLOCK RAM,另一种是由LUT配置成的内部存储器（也就是分布式RAM）。BLOCK RAM由一定数量固定大小的存储块构成的，使用BLOCK RAM资源不占用额外的逻辑资源，并且速度快。但是使用的时候消耗的BLOCK RAM资源是其块大小的整数倍。</p>
<h3 id="15：什么是时钟抖动？"><a href="#15：什么是时钟抖动？" class="headerlink" title="15：什么是时钟抖动？"></a>15：什么是时钟抖动？</h3><p>时钟抖动是指芯片的某一个给定点上时钟周期发生暂时性变化，也就是说时钟周期在不同的周期上可能加长或缩短。它是一个平均值为0的平均变量。</p>
<h3 id="16：FPGA设计中对时钟的使用？（例如分频等）"><a href="#16：FPGA设计中对时钟的使用？（例如分频等）" class="headerlink" title="16：FPGA设计中对时钟的使用？（例如分频等）"></a>16：FPGA设计中对时钟的使用？（例如分频等）</h3><p>FPGA芯片有固定的时钟路由，这些路由能有减少时钟抖动和偏差。需要对时钟进行相位移动或变频的时候，一般不允许对时钟进行逻辑操作，这样不仅会增加时钟的偏差和抖动，还会使时钟带上毛刺。一般的处理方法是采用FPGA芯片自带的时钟管理器如PLL,DLL或DCM，或者把逻辑转换到触发器的D输入（这些也是对时钟逻辑操作的替代方案）。</p>
<h3 id="17：FPGA设计中如何实现同步时序电路的延时？"><a href="#17：FPGA设计中如何实现同步时序电路的延时？" class="headerlink" title="17：FPGA设计中如何实现同步时序电路的延时？"></a>17：FPGA设计中如何实现同步时序电路的延时？</h3><p>首先说说异步电路的延时实现：异步电路一半是通过加buffer、两级与非门等来实现延时（我还没用过所以也不是很清楚），但这是不适合同步电路实现延时的。在同步电路中，对于比较大的和特殊要求的延时，一半通过高速时钟产生计数器，通过计数器来控制延时；对于比较小的延时，可以通过触发器打一拍，不过这样只能延迟一个时钟周期。</p>
<h3 id="18：FPGA中可以综合实现为RAM-ROM-CAM的三种资源及其注意事项？"><a href="#18：FPGA中可以综合实现为RAM-ROM-CAM的三种资源及其注意事项？" class="headerlink" title="18：FPGA中可以综合实现为RAM/ROM/CAM的三种资源及其注意事项？"></a>18：FPGA中可以综合实现为RAM/ROM/CAM的三种资源及其注意事项？</h3><p>三种资源：BLOCK RAM，触发器（FF），查找表（LUT）；</p>
<p>注意事项：</p>
<p>1：在生成RAM等存储单元时，应该首选BLOCK RAM 资源；其原因有二：第一：使用BLOCK RAM等资源，可以节约更多的FF和4-LUT等底层可编程单元。使用BLOCK RAM可以说是“不用白不用”，是最大程度发挥器件效能，节约成本的一种体现；第二：BLOCK RAM是一种可以配置的硬件结构，其可靠性和速度与用LUT和REGISTER构建的存储器更有优势。</p>
<p>2：弄清FPGA的硬件结构，合理使用BLOCK RAM资源；</p>
<p>3：分析BLOCK RAM容量，高效使用BLOCK RAM资源；</p>
<p>4：分布式RAM资源（DISTRIBUTE RAM）</p>
<h3 id="19：Xilinx中与全局时钟资源和DLL相关的硬件原语："><a href="#19：Xilinx中与全局时钟资源和DLL相关的硬件原语：" class="headerlink" title="19：Xilinx中与全局时钟资源和DLL相关的硬件原语："></a>19：Xilinx中与全局时钟资源和DLL相关的硬件原语：</h3><p>常用的与全局时钟资源相关的Xilinx器件原语包括：IBUFG,IBUFGDS,BUFG,BUFGP,BUFGCE,BUFGMUX,BUFGDLL,DCM等。关于各个器件原语的解释可以参考《FPGA设计指导准则》p50部分。</p>
<h3 id="20：HDL语言的层次概念？"><a href="#20：HDL语言的层次概念？" class="headerlink" title="20：HDL语言的层次概念？"></a>20：HDL语言的层次概念？</h3><p>HDL语言是分层次的、类型的，最常用的层次概念有系统与标准级、功能模块级，行为级，寄存器传输级和门级。</p>
<p>系统级，算法级，RTL级(行为级)，门级，开关级</p>
<h3 id="21：查找表的原理与结构？"><a href="#21：查找表的原理与结构？" class="headerlink" title="21：查找表的原理与结构？"></a>21：查找表的原理与结构？</h3><p>查找表（look-up-table）简称为LUT，LUT本质上就是一个RAM。目前FPGA中多使用4输入的LUT，所以每一个LUT可以看成一个有 4位地址线的16x1的RAM。当用户通过原理图或HDL语言描述了一个逻辑电路以后，PLD/FPGA开发软件会自动计算逻辑电路的所有可能的结果，并把结果事先写入RAM,这样，每输入一个信号进行逻辑运算就等于输入一个地址进行查表，找出地址对应的内容，然后输出即可</p>
<h3 id="22：IC设计前端到后端的流程和EDA工具？"><a href="#22：IC设计前端到后端的流程和EDA工具？" class="headerlink" title="22：IC设计前端到后端的流程和EDA工具？"></a>22：IC设计前端到后端的流程和EDA工具？</h3><p>设计前端也称逻辑设计，后端设计也称物理设计，两者并没有严格的界限，一般涉及到与工艺有关的设计就是后端设计。</p>
<p>1：规格制定：客户向芯片设计公司提出设计要求。</p>
<p>2：详细设计：芯片设计公司（Fabless）根据客户提出的规格要求，拿出设计解决方案和具体实现架构，划分模块功能。目前架构的验证一般基于systemC语言，对价后模型的仿真可以使用systemC的仿真工具。例如：CoCentric和Visual Elite等。</p>
<p>3：HDL编码：设计输入工具：ultra ，visual VHDL等</p>
<p>4：仿真验证：modelsim</p>
<p>5：逻辑综合：synplify</p>
<p>6：静态时序分析：synopsys的Prime Time</p>
<p>7：形式验证：Synopsys的Formality.</p>
<h3 id="23：寄生效应在IC设计中怎样加以克服和利用？"><a href="#23：寄生效应在IC设计中怎样加以克服和利用？" class="headerlink" title="23：寄生效应在IC设计中怎样加以克服和利用？"></a>23：寄生效应在IC设计中怎样加以克服和利用？</h3><p>比较复杂，参考集成电路原理相关书籍。</p>
<h3 id="24：用flip-flop和logic-gate设计一个1位加法器，输入carryin和current-stage，输出carryout和next-stage？"><a href="#24：用flip-flop和logic-gate设计一个1位加法器，输入carryin和current-stage，输出carryout和next-stage？" class="headerlink" title="24：用flip-flop和logic-gate设计一个1位加法器，输入carryin和current-stage，输出carryout和next-stage？"></a>24：用flip-flop和logic-gate设计一个1位加法器，输入carryin和current-stage，输出carryout和next-stage？</h3><p>不解释</p>
<h3 id="25：设计一个自动饮料售卖机，饮料10分钱，硬币有5分和10分两种，并考虑找零"><a href="#25：设计一个自动饮料售卖机，饮料10分钱，硬币有5分和10分两种，并考虑找零" class="headerlink" title="25：设计一个自动饮料售卖机，饮料10分钱，硬币有5分和10分两种，并考虑找零"></a>25：设计一个自动饮料售卖机，饮料10分钱，硬币有5分和10分两种，并考虑找零</h3><p>1.画出fsm（有限状态机）</p>
<p>2.用verilog编程，语法要符合FPGA设计的要求</p>
<p>3.设计工程中可使用的工具及设计大致过程？</p>
<p>设计过程：</p>
<p>1、首先确定输入输出，A=1表示投入10分，B=1表示投入5分，Y=1表示弹出饮料，Z=1表示找零。</p>
<p>2、确定电路的状态，S0表示没有进行投币，S1表示已经有5分硬币。</p>
<p>3、画出状态转移图。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> sell(clk,rst,a,b,y,z);</span><br><span class="line">    <span class="keyword">input</span> clk,rst,a,b;</span><br><span class="line">    <span class="keyword">output</span> y,z;</span><br><span class="line">    <span class="keyword">parameter</span> s0=<span class="number">0</span>,s1=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">reg</span> state,next_state;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!rst)</span><br><span class="line">        state&lt;=s0;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        state&lt;=next_state;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span>@(a <span class="keyword">or</span> b <span class="keyword">or</span> cstate)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        y=<span class="number">0</span>;z=<span class="number">0</span>;    </span><br><span class="line">        <span class="keyword">case</span>(state)</span><br><span class="line">        s0: <span class="keyword">if</span>(a==<span class="number">1</span>&amp;&amp;b==<span class="number">0</span>)next_state=s1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">0</span>&amp;&amp;b==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            next_state=s0;y=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        next_state=s0;</span><br><span class="line">        s1: <span class="keyword">if</span>(a==<span class="number">1</span>&amp;&amp;b==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            next_state=s0;y=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">0</span>&amp;&amp;b==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            next_state=s0;y=<span class="number">1</span>;z=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        next_state=s0;</span><br><span class="line">        <span class="keyword">default</span>: next_state=s0;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>扩展：设计一个自动售饮料机的逻辑电路。它的投币口每次只能投入一枚五角或一元的硬币。投入一元五角硬币后给出饮料；投入两元硬币时给出饮料并找回五角。</p>
<p>1、确定输入输出，投入一元硬币A=1，投入五角硬币B=1，给出饮料Y=1，找回五角Z=1；</p>
<p>2、确定电路的状态数，投币前初始状态为S0，投入五角硬币为S1，投入一元硬币为S2。画出转该转移图，根据状态转移图可以写成Verilog代码。</p>
<h3 id="26：什么是”线与”逻辑-要实现它-在硬件特性上有什么具体要求"><a href="#26：什么是”线与”逻辑-要实现它-在硬件特性上有什么具体要求" class="headerlink" title="26：什么是”线与”逻辑,要实现它,在硬件特性上有什么具体要求?"></a>26：什么是”线与”逻辑,要实现它,在硬件特性上有什么具体要求?</h3><p>线与逻辑是两个输出信号相连可以实现与的功能。在硬件上,要用oc门来实现,由于不用oc门可能使灌电流过大,而烧坏逻辑门. 同时在输出端口应加一个上拉电阻。oc门就是集电极开路门。od门是漏极开路门。</p>
<h3 id="27：什么是竞争与冒险现象-怎样判断-如何消除"><a href="#27：什么是竞争与冒险现象-怎样判断-如何消除" class="headerlink" title="27：什么是竞争与冒险现象?怎样判断?如何消除?"></a>27：什么是竞争与冒险现象?怎样判断?如何消除?</h3><p>在组合电路中，某一输入变量经过不同途径传输后，到达电路中某一汇合点的时间有先有后，这种现象称竞争；由于竞争而使电路输出发生瞬时错误的现象叫做冒险。（也就是由于竞争产生的毛刺叫做冒险）。</p>
<p>判断方法：代数法（如果布尔式中有相反的信号则可能产生竞争和冒险现象）；卡诺图：有两个相切的卡诺圈并且相切处没有被其他卡诺圈包围，就有可能出现竞争冒险；实验法：示波器观测；</p>
<p>解决方法：1：加滤波电容，消除毛刺的影响；2：加选通信号，避开毛刺；3：增加冗余项消除逻辑冒险。</p>
<p>门电路两个输入信号同时向相反的逻辑电平跳变称为竞争；</p>
<p>由于竞争而在电路的输出端可能产生尖峰脉冲的现象称为竞争冒险。</p>
<p>如果逻辑函数在一定条件下可以化简成Y=A+A’或Y=AA’则可以判断存在竞争冒险现象（只是一个变量变化的情况）。</p>
<p>消除方法，接入滤波电容，引入选通脉冲，增加冗余逻辑</p>
<h3 id="28：你知道那些常用逻辑电平-TTL与COMS电平可以直接互连吗？"><a href="#28：你知道那些常用逻辑电平-TTL与COMS电平可以直接互连吗？" class="headerlink" title="28：你知道那些常用逻辑电平?TTL与COMS电平可以直接互连吗？"></a>28：你知道那些常用逻辑电平?TTL与COMS电平可以直接互连吗？</h3><p>常用逻辑电平：12V，5V，3.3V。</p>
<p>TTL和CMOS 不可以直接互连，由于TTL是在0.3-3.6V之间，而CMOS则是有在12V的有在5V的。CMOS输出接到TTL是可以直接互连。TTL接到 CMOS需要在输出端口加一上拉电阻接到5V或者12V。</p>
<p>用CMOS可直接驱动TTL;加上拉电阻后,TTL可驱动CMOS.</p>
<p>上拉电阻用途：</p>
<p>1、当TTL电路驱动CMOS电路时，如果TTL电路输出的高电平低于COMS电路的最低高电平（一般为3.5V），这时就需要在TTL的输出端接上拉电阻，以提高输出高电平的值。</p>
<p>2、OC门电路必须加上拉电阻，以提高输出的高电平值。</p>
<p>3、为加大输出引脚的驱动能力，有的单片机管脚上也常使用上拉电阻。</p>
<p>4、在CMOS芯片上，为了防止静电造成损坏，不用的管脚不能悬空，一般接上拉电阻产生降低输入阻抗，提供泄荷通路。</p>
<p>5、芯片的管脚加上拉电阻来提高输出电平，从而提高芯片输入信号的噪声容限增强抗干扰能力。</p>
<p>6、提高总线的抗电磁干扰能力。管脚悬空就比较容易接受外界的电磁干扰。</p>
<p>7、长线传输中电阻不匹配容易引起反射波干扰，加上下拉电阻是电阻匹配，有效的抑制反射波干扰。</p>
<p>上拉电阻阻值的选择原则包括:</p>
<p>1、从节约功耗及芯片的灌电流能力考虑应当足够大；电阻大，电流小。</p>
<p>2、从确保足够的驱动电流考虑应当足够小；电阻小，电流大。</p>
<p>3、对于高速电路，过大的上拉电阻可能边沿变平缓。综合考虑以上三点,通常在1k到10k之间选取。对下拉电阻也有类似道理。</p>
<p>OC门电路必须加上拉电阻，以提高输出的高电平值。</p>
<p>OC门电路要输出“1”时才需要加上拉电阻不加根本就没有高电平</p>
<p>在有时我们用OC门作驱动（例如控制一个 LED）灌电流工作时就可以不加上拉电阻</p>
<p>总之加上拉电阻能够提高驱动能力。</p>
<h3 id="29：IC设计中同步复位与异步复位的区别？"><a href="#29：IC设计中同步复位与异步复位的区别？" class="headerlink" title="29：IC设计中同步复位与异步复位的区别？"></a>29：IC设计中同步复位与异步复位的区别？</h3><p>同步复位在时钟沿变化时，完成复位动作。异步复位不管时钟，只要复位信号满足条件，就完成复位动作。异步复位对复位信号要求比较高，不能有毛刺，如果其与时钟关系不确定，也可能出现亚稳态。</p>
<h3 id="30：MOORE-与-MEELEY状态机的特征？"><a href="#30：MOORE-与-MEELEY状态机的特征？" class="headerlink" title="30：MOORE 与 MEELEY状态机的特征？"></a>30：MOORE 与 MEELEY状态机的特征？</h3><p>Moore 状态机的输出仅与当前状态值有关, 且只在时钟边沿到来时才会有状态变化。</p>
<p>Mealy 状态机的输出不仅与当前状态值有关, 而且与当前输入值有关。</p>
<h3 id="31：多时钟域设计中-如何处理信号跨时钟域？"><a href="#31：多时钟域设计中-如何处理信号跨时钟域？" class="headerlink" title="31：多时钟域设计中,如何处理信号跨时钟域？"></a>31：多时钟域设计中,如何处理信号跨时钟域？</h3><p>不同的时钟域之间信号通信时需要进行同步处理，这样可以防止新时钟域中第一级触发器的亚稳态信号对下级逻辑造成影响。</p>
<p>信号跨时钟域同步：当单个信号跨时钟域时，可以采用两级触发器来同步；数据或地址总线跨时钟域时可以采用异步FIFO来实现时钟同步；第三种方法就是采用握手信号。</p>
<h3 id="32：说说静态、动态时序模拟的优缺点？"><a href="#32：说说静态、动态时序模拟的优缺点？" class="headerlink" title="32：说说静态、动态时序模拟的优缺点？"></a>32：说说静态、动态时序模拟的优缺点？</h3><p>静态时序分析是采用穷尽分析方法来提取出整个电路存在的所有时序路径， 计算信号在这些路径上的传播延时，检查信号的建立和保持时间是否满足时序要求，通过对最大路径延时和最小路径延时的分析，找出违背时序约束的错误。它不需 要输入向量就能穷尽所有的路径，且运行速度很快、占用内存较少，不仅可以对芯片设计进行全面的时序功能检查，而且还可利用时序分析的结果来优化设计，因此 静态时序分析已经越来越多地被用到数字集成电路设计的验证中。</p>
<p>动态时序模拟就是通常的仿真，因为不可能产生完备的测试向量，覆盖门级网表中的每一条路径。因此在动态时序分析中，无法暴露一些路径上可能存在的时序问题；</p>
<h3 id="33：一个四级的Mux-其中第二级信号为关键信号如何改善timing-？"><a href="#33：一个四级的Mux-其中第二级信号为关键信号如何改善timing-？" class="headerlink" title="33：一个四级的Mux,其中第二级信号为关键信号如何改善timing.？"></a>33：一个四级的Mux,其中第二级信号为关键信号如何改善timing.？</h3><p>关键：将第二级信号放到最后输出一级输出，同时注意修改片选信号，保证其优先级未被修改。（为什么？）</p>
<h3 id="34：给出一个门级的图-又给了各个门的传输延时-问关键路径是什么-还问给出输入-使得输出依赖于关键路径？"><a href="#34：给出一个门级的图-又给了各个门的传输延时-问关键路径是什么-还问给出输入-使得输出依赖于关键路径？" class="headerlink" title="34：给出一个门级的图,又给了各个门的传输延时,问关键路径是什么,还问给出输入, 使得输出依赖于关键路径？"></a>34：给出一个门级的图,又给了各个门的传输延时,问关键路径是什么,还问给出输入, 使得输出依赖于关键路径？</h3><p>关键路径就是输入到输出延时最大的路径，找到了关键路径便能求得最大时钟频率。</p>
<h3 id="35：为什么一个标准的倒相器中P管的宽长比要比N管的宽长比大"><a href="#35：为什么一个标准的倒相器中P管的宽长比要比N管的宽长比大" class="headerlink" title="35：为什么一个标准的倒相器中P管的宽长比要比N管的宽长比大?"></a>35：为什么一个标准的倒相器中P管的宽长比要比N管的宽长比大?</h3><p>和载流子有关，P管是空穴导电，N管是电子导电，电子的迁移率大于空穴，同样的电场下，N管的电流大于P管，因此要增大P管的宽长比，使之对称，这样才能使得两者上升时间下降时间相等、高低电平的噪声容限一样、充电放电的时间相等。</p>
<h3 id="36：用mos管搭出一个二输入与非门？"><a href="#36：用mos管搭出一个二输入与非门？" class="headerlink" title="36：用mos管搭出一个二输入与非门？"></a>36：用mos管搭出一个二输入与非门？</h3><p>参考数字集成电路的相关书籍</p>
<h3 id="37：画出NOT-NAND-NOR的符号-真值表-还有transistor-level（晶体管级）的电路？"><a href="#37：画出NOT-NAND-NOR的符号-真值表-还有transistor-level（晶体管级）的电路？" class="headerlink" title="37：画出NOT,NAND,NOR的符号,真值表,还有transistor level（晶体管级）的电路？"></a>37：画出NOT,NAND,NOR的符号,真值表,还有transistor level（晶体管级）的电路？</h3><p>参考数字集成电路的相关书籍</p>
<h3 id="38：画出tow-to-one-muxgate的电路图？"><a href="#38：画出tow-to-one-muxgate的电路图？" class="headerlink" title="38：画出tow-to-one muxgate的电路图？"></a>38：画出tow-to-one muxgate的电路图？</h3><p>Y=SA+S’B 利用与非门和反相器，进行变换后Y=((SA)’*(S’A)’)’，三个与非门，一个反相器。也可以用传输门来实现数据选择器或者是异或门。</p>
<h3 id="39：用一个二选一mux和一个inv实现异或？"><a href="#39：用一个二选一mux和一个inv实现异或？" class="headerlink" title="39：用一个二选一mux和一个inv实现异或？"></a>39：用一个二选一mux和一个inv实现异或？</h3><p>其中:B连接的是地址输入端，A和A非连接的是数据选择端,F对应的的是输出端,使能端固定接地置零(没有画出来).</p>
<p>Y=BA’+B’A</p>
<p>利用4选1实现F(x,y,z)=xz+yz’ </p>
<p>F(x,y,z)=xyz+xy’z+xyz’+x’yz’=x’y’0+x’yz’+xy’z+xy1</p>
<p>Y=A’B’D0+A’BD1+AB’D2+ABD3</p>
<p>所以D0=0，D1=z’，D2=z，D3=1</p>
<h3 id="40：画出CMOS电路的晶体管级电路图-实现Y-AB-C-D-E-，画出Y-AB-C的CMOS电路图，画出Y-AB-CD的CMOS电路图。"><a href="#40：画出CMOS电路的晶体管级电路图-实现Y-AB-C-D-E-，画出Y-AB-C的CMOS电路图，画出Y-AB-CD的CMOS电路图。" class="headerlink" title="40：画出CMOS电路的晶体管级电路图,实现Y=AB+C(D+E)，画出Y=AB+C的CMOS电路图，画出Y=AB+CD的CMOS电路图。"></a>40：画出CMOS电路的晶体管级电路图,实现Y=A<em>B+C(D+E)，画出Y=A</em>B+C的CMOS电路图，画出Y=A<em>B+C</em>D的CMOS电路图。</h3><p>利用与非门和或非门实现</p>
<p>Y=A*B+C(D+E)=((AB’)(CD)’(CE)’)’ 三个两输入与非门，一个三输入与非门</p>
<p>Y=A*B+C=((AB)’C’) 一个反相器，两个两输入与非门</p>
<p>Y=A<em>B+C</em>D=((AB)’(CD)’)’ 三个两输入与非门</p>
<h3 id="41：用与非门等设计全加法器？"><a href="#41：用与非门等设计全加法器？" class="headerlink" title="41：用与非门等设计全加法器？"></a>41：用与非门等设计全加法器？</h3><p>不解释</p>
<h3 id="42：A-B-C-D-E进行投票-多数服从少数-输出是F-也就是如果A-B-C-D-E中1的个数比0-多-那么F输出为1-否则F为0-用与非门实现-输入数目没有限制？（与非-与非形式）"><a href="#42：A-B-C-D-E进行投票-多数服从少数-输出是F-也就是如果A-B-C-D-E中1的个数比0-多-那么F输出为1-否则F为0-用与非门实现-输入数目没有限制？（与非-与非形式）" class="headerlink" title="42：A,B,C,D,E进行投票,多数服从少数,输出是F(也就是如果A,B,C,D,E中1的个数比0 多,那么F输出为1,否则F为0),用与非门实现,输入数目没有限制？（与非-与非形式）"></a>42：A,B,C,D,E进行投票,多数服从少数,输出是F(也就是如果A,B,C,D,E中1的个数比0 多,那么F输出为1,否则F为0),用与非门实现,输入数目没有限制？（与非-与非形式）</h3><p>先画出卡诺图来化简，化成与或形式，再两次取反便可。</p>
<h3 id="43：画出一种CMOS的D锁存器的电路图和版图？"><a href="#43：画出一种CMOS的D锁存器的电路图和版图？" class="headerlink" title="43：画出一种CMOS的D锁存器的电路图和版图？"></a>43：画出一种CMOS的D锁存器的电路图和版图？</h3><p>参考数字集成电路的相关书籍</p>
<h3 id="44：LATCH和DFF的概念和区别？"><a href="#44：LATCH和DFF的概念和区别？" class="headerlink" title="44：LATCH和DFF的概念和区别？"></a>44：LATCH和DFF的概念和区别？</h3><h3 id="45：latch与register的区别-为什么现在多用register-行为级描述中latch如何产生的？"><a href="#45：latch与register的区别-为什么现在多用register-行为级描述中latch如何产生的？" class="headerlink" title="45：latch与register的区别,为什么现在多用register.行为级描述中latch如何产生的？"></a>45：latch与register的区别,为什么现在多用register.行为级描述中latch如何产生的？</h3><p>latch是电平触发，register是边沿触发，register在同一时钟边沿触发下动作，符合同步电路的设计思想，而latch则属于异步电路设计，往往会导致时序分析困难，不适当的应用latch则会大量浪费芯片资源。</p>
<h3 id="46：用D触发器做个二分频的电路？画出逻辑电路？"><a href="#46：用D触发器做个二分频的电路？画出逻辑电路？" class="headerlink" title="46：用D触发器做个二分频的电路？画出逻辑电路？"></a>46：用D触发器做个二分频的电路？画出逻辑电路？</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> div2(clk,rst,clk_out);</span><br><span class="line">    <span class="keyword">input</span> clk,rst;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> clk_out;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!rst)</span><br><span class="line">        clk_out &lt;=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        clk_out &lt;=~ clk_out;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>现实工程设计中一般不采用这样的方式来设计，二分频一般通过DCM来实现。通过DCM得到的分频信号没有相位差。</p>
<h3 id="47：什么是状态图？"><a href="#47：什么是状态图？" class="headerlink" title="47：什么是状态图？"></a>47：什么是状态图？</h3><p>状态图是以几何图形的方式来描述时序逻辑电路的状态转移规律以及输出与输入的关系。</p>
<h3 id="48：用你熟悉的设计方式设计一个可预置初值的7进制循环计数器-15进制的呢？"><a href="#48：用你熟悉的设计方式设计一个可预置初值的7进制循环计数器-15进制的呢？" class="headerlink" title="48：用你熟悉的设计方式设计一个可预置初值的7进制循环计数器,15进制的呢？"></a>48：用你熟悉的设计方式设计一个可预置初值的7进制循环计数器,15进制的呢？</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> counter7(clk,rst,load,data,cout);</span><br><span class="line">    <span class="keyword">input</span> clk,rst,load;</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] data;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] cout;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(!rst)</span><br><span class="line">        cout&lt;=<span class="number">3</span>’d0;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(load)</span><br><span class="line">        cout&lt;=data;      </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cout&gt;=<span class="number">3</span>’d6)</span><br><span class="line">        cout&lt;=<span class="number">3</span>’d0;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        cout&lt;=cout+<span class="number">3</span>’d1;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="49：你所知道的可编程逻辑器件有哪些？"><a href="#49：你所知道的可编程逻辑器件有哪些？" class="headerlink" title="49：你所知道的可编程逻辑器件有哪些？"></a>49：你所知道的可编程逻辑器件有哪些？</h3><p>PAL，PLA，GAL，CPLD，FPGA</p>
<h3 id="50：用Verilog或VHDL写一段代码-实现消除一个glitch（毛刺）？"><a href="#50：用Verilog或VHDL写一段代码-实现消除一个glitch（毛刺）？" class="headerlink" title="50：用Verilog或VHDL写一段代码,实现消除一个glitch（毛刺）？"></a>50：用Verilog或VHDL写一段代码,实现消除一个glitch（毛刺）？</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法无法消除毛刺，只能减少其概率，若经过两级触发器，可以认为毛刺很小可以忽略</span></span><br><span class="line"><span class="keyword">module</span>(clk,data,q_out)</span><br><span class="line">    <span class="keyword">input</span> clk,data;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> q_out;</span><br><span class="line">    <span class="keyword">reg</span> q1;</span><br><span class="line">    <span class="keyword">always</span>@(posedgeclk)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        q1&lt;=data;</span><br><span class="line">        q_out&lt;=q1;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://mike-rush.github.io/2020/05/12/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80100%E9%A2%98P1/" data-id="cka3dzupx0000x8r2gsxoctph" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/05/11/%E6%97%B6%E9%92%9F%E5%88%87%E6%8D%A2%E4%B8%AD%E7%9A%84glitch/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">时钟切换中的glitch</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/05/12/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80100%E9%A2%98P1/">数字IC设计基础知识100题（Part I）</a>
          </li>
        
          <li>
            <a href="/2020/05/11/%E6%97%B6%E9%92%9F%E5%88%87%E6%8D%A2%E4%B8%AD%E7%9A%84glitch/">时钟切换中的glitch</a>
          </li>
        
          <li>
            <a href="/2020/05/11/PCB%E5%90%8D%E7%89%87%E9%A1%B9%E7%9B%AE%E2%80%94%E6%9E%84%E6%83%B3/">PCB名片项目—构想</a>
          </li>
        
          <li>
            <a href="/2020/05/11/MC-0-5um-PDK/">CSMC 0.5um PDK</a>
          </li>
        
          <li>
            <a href="/2020/05/10/%E3%80%90%E9%9B%86%E5%88%9B%E8%B5%9B%E3%80%91ARM%E6%9D%AF%E7%AC%AC%E4%BA%94%E8%AF%BE%E5%9F%B9%E8%AE%AD/">【集创赛】ARM杯第五课培训</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Mike Rush<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>